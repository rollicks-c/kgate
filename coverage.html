
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>kgate: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rollicks-c/kgate/cmd/kgate/kgate.go (0.0%)</option>
				
				<option value="file1">github.com/rollicks-c/kgate/internal/cli/api.go (0.0%)</option>
				
				<option value="file2">github.com/rollicks-c/kgate/internal/cli/commands/forwards/api.go (0.0%)</option>
				
				<option value="file3">github.com/rollicks-c/kgate/internal/cli/commands/forwards/forwards.go (0.0%)</option>
				
				<option value="file4">github.com/rollicks-c/kgate/internal/cli/commands/groups/api.go (0.0%)</option>
				
				<option value="file5">github.com/rollicks-c/kgate/internal/cli/commands/profile/api.go (0.0%)</option>
				
				<option value="file6">github.com/rollicks-c/kgate/internal/cli/commands/profile/profile.go (0.0%)</option>
				
				<option value="file7">github.com/rollicks-c/kgate/internal/cli/menu.go (0.0%)</option>
				
				<option value="file8">github.com/rollicks-c/kgate/internal/config/api.go (33.3%)</option>
				
				<option value="file9">github.com/rollicks-c/kgate/internal/logic/forwarding/api.go (0.0%)</option>
				
				<option value="file10">github.com/rollicks-c/kgate/internal/logic/forwarding/forwarding.go (9.4%)</option>
				
				<option value="file11">github.com/rollicks-c/kgate/internal/logic/forwarding/k9s.go (0.0%)</option>
				
				<option value="file12">github.com/rollicks-c/kgate/internal/logic/gate/api.go (0.0%)</option>
				
				<option value="file13">github.com/rollicks-c/kgate/internal/logic/gate/controller.go (0.0%)</option>
				
				<option value="file14">github.com/rollicks-c/kgate/internal/logic/gate/session.go (0.0%)</option>
				
				<option value="file15">github.com/rollicks-c/kgate/internal/logic/ui/api.go (0.0%)</option>
				
				<option value="file16">github.com/rollicks-c/kgate/internal/logic/ui/fancy/api.go (0.0%)</option>
				
				<option value="file17">github.com/rollicks-c/kgate/internal/logic/ui/fancy/fancy.go (0.0%)</option>
				
				<option value="file18">github.com/rollicks-c/kgate/internal/logic/ui/fancy/layout.go (0.0%)</option>
				
				<option value="file19">github.com/rollicks-c/kgate/internal/logic/ui/simple/ui.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/rollicks-c/kgate/internal/cli"
        "github.com/rollicks-c/term"
        "os"
)

func main() <span class="cov0" title="0">{

        if err := cli.CreateClient().Run(os.Args); err != nil </span><span class="cov0" title="0">{
                term.Failf("%s\n", err.Error())
        }</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cli

import (
        "github.com/rollicks-c/kgate/internal/cli/commands/forwards"
        "github.com/rollicks-c/kgate/internal/config"
        "github.com/urfave/cli/v2"
)

func CreateClient() *cli.App <span class="cov0" title="0">{
        app := cli.NewApp()
        app.Name = config.AppName
        app.Usage = config.Usage
        app.Commands = createCommands()
        app.Action = forwards.StartAll
        return app
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package forwards

import (
        "github.com/urfave/cli/v2"
)

var (
        FlagGroup = &amp;cli.StringSliceFlag{
                Name:    "group",
                Aliases: []string{"g"},
        }
        FlagAll = &amp;cli.BoolFlag{
                Name:    "all",
                Value:   false,
                Aliases: []string{"a"},
        }
)

func Start(c *cli.Context) error <span class="cov0" title="0">{
        selectedGroups := FlagGroup.Get(c)
        allGroups := FlagAll.Get(c)
        return startGroups(allGroups, selectedGroups...)
}</span>

func StartAll(c *cli.Context) error <span class="cov0" title="0">{
        return startGroups(true)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package forwards

import (
        "fmt"
        "github.com/rollicks-c/kgate/internal/config"
        "github.com/rollicks-c/kgate/internal/logic/gate"
)

func startGroups(allGroups bool, selectedGroups ...string) error <span class="cov0" title="0">{

        // sanity check
        if allGroups &amp;&amp; len(selectedGroups) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot use -%s and -%s together", FlagAll.Name, FlagGroup.Name)
        }</span>

        // load data
        <span class="cov0" title="0">profile := config.Profiles().LoadCurrent()
        var groups []config.PortGroup
        if allGroups </span><span class="cov0" title="0">{
                groups = profile.Data.Groups
        }</span> else<span class="cov0" title="0"> {
                groups = filterGroups(profile.Data.Groups, selectedGroups)
        }</span>

        // start forwards
        <span class="cov0" title="0">if err := gate.RunGroups(groups...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func filterGroups(pool []config.PortGroup, selectedNames []string) []config.PortGroup <span class="cov0" title="0">{
        var res []config.PortGroup
        for _, g := range pool </span><span class="cov0" title="0">{
                if contains(selectedNames, g.Name) </span><span class="cov0" title="0">{
                        res = append(res, g)
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func contains(groups []string, name string) bool <span class="cov0" title="0">{
        for _, g := range groups </span><span class="cov0" title="0">{
                if g == name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>

}
</pre>
		
		<pre class="file" id="file4" style="display: none">package groups

import (
        "github.com/rollicks-c/kgate/internal/config"
        "github.com/rollicks-c/term"
        "github.com/urfave/cli/v2"
)

func List(c *cli.Context) error <span class="cov0" title="0">{

        profile := config.Profiles().LoadCurrent()
        term.Infof("profile [%s]\ngroups:\n", profile.Name)
        for _, g := range profile.Data.Groups </span><span class="cov0" title="0">{
                term.Infof("    - %s [%s]\n", g.Name, g.Target.K8sContext)
                for _, pf := range g.PortForwards </span><span class="cov0" title="0">{
                        term.Infof("        - %s:%s/%s:%s\n", pf.LocalPort, pf.Namespace, pf.Service, pf.RemotePort)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package profile

import (
        "fmt"
        "github.com/rollicks-c/kgate/internal/config"
        "github.com/rollicks-c/term"
        "github.com/urfave/cli/v2"
)

func Switch(c *cli.Context) error <span class="cov0" title="0">{

        // no args: show current profile
        if c.Args().Len() == 0 </span><span class="cov0" title="0">{
                showProfile()
                return nil
        }</span>

        // switch
        <span class="cov0" title="0">if err := switchProfile(c.Args().First()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func List(c *cli.Context) error <span class="cov0" title="0">{

        profileList := config.Profiles().List()
        term.Infof("profiles:\n")
        for _, p := range profileList </span><span class="cov0" title="0">{
                active := ""
                if p == config.Profiles().LoadCurrent().Name </span><span class="cov0" title="0">{
                        active = " (active)"
                }</span>
                <span class="cov0" title="0">term.Infof("\t- %s%s\n", p, active)</span>

        }

        <span class="cov0" title="0">return nil</span>
}

func Create(c *cli.Context) error <span class="cov0" title="0">{

        // gather profile name
        profileName := c.Args().First()
        if profileName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("profile name is required")
        }</span>

        // avoid name collision
        <span class="cov0" title="0">profileList := config.Profiles().List()
        term.Infof("profiles:\n")
        for _, p := range profileList </span><span class="cov0" title="0">{

                if p == profileName </span><span class="cov0" title="0">{
                        return fmt.Errorf("profile %s already exists\n", profileName)
                }</span>
        }

        // create profile
        <span class="cov0" title="0">template := config.Profiles().LoadCurrent()
        template.Name = profileName
        template.Data.Groups = append(template.Data.Groups, config.PortGroup{
                Target: config.Target{
                        K8sConfigFile: "${HOME}/.kube/config",
                        K8sContext:    "context1",
                },
                PortForwards: []config.PortForward{
                        {
                                Namespace:  "namespace1",
                                Service:    "service1",
                                LocalPort:  "8080",
                                RemotePort: "8080",
                        },
                },
                Name: "group1",
        })
        config.Profiles().Update(template)

        term.Infof("profile %s created\n", profileName)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package profile

import (
        "github.com/rollicks-c/kgate/internal/config"
        "github.com/rollicks-c/term"
        "strings"
)

func showProfile() <span class="cov0" title="0">{
        profileName := config.Profiles().LoadCurrent().Name
        term.Infof("profile: %s\n", profileName)
}</span>

func switchProfile(exp string) error <span class="cov0" title="0">{

        // fuzzy match
        pList := config.Profiles().List()
        sel := make([]string, 0)
        for _, p := range pList </span><span class="cov0" title="0">{
                if strings.HasPrefix(p, exp) </span><span class="cov0" title="0">{
                        sel = append(sel, p)
                }</span>
        }
        <span class="cov0" title="0">if len(sel) == 0 </span><span class="cov0" title="0">{
                term.Failf("no profile found matching [%s]\n", exp)
                return nil
        }</span>
        <span class="cov0" title="0">if len(sel) &gt; 1 </span><span class="cov0" title="0">{
                term.Failf("multiple profiles found matching [%s]: %s\n", exp, strings.Join(sel, ", "))
                return nil
        }</span>
        <span class="cov0" title="0">profileName := sel[0]

        // switch
        err := config.Profiles().Switch(profileName)
        if err != nil </span><span class="cov0" title="0">{
                term.Failf("failed to switch profile: [%s]\n", err)
                return err
        }</span>
        <span class="cov0" title="0">term.Successf("switched to profile [%s]\n", profileName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cli

import (
        "github.com/rollicks-c/kgate/internal/cli/commands/forwards"
        "github.com/rollicks-c/kgate/internal/cli/commands/groups"
        "github.com/rollicks-c/kgate/internal/cli/commands/profile"
        "github.com/urfave/cli/v2"
)

func createCommands() []*cli.Command <span class="cov0" title="0">{

        cmdList := []*cli.Command{
                createForwardCommands(),
                createGroupsCommands(),
                createProfileCommands(),
        }
        return cmdList
}</span>

func createForwardCommands() *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:    "forward",
                Aliases: []string{"f"},
                Action:  forwards.Start,
                Usage:   "forwards [-a | -g &lt;g1&gt;, -g &lt;g2&gt;,...]",
                Flags: []cli.Flag{
                        forwards.FlagGroup,
                        forwards.FlagAll,
                },
        }
}</span>

func createGroupsCommands() *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:    "groups",
                Aliases: []string{"g"},
                Action:  groups.List,
                Subcommands: []*cli.Command{
                        {
                                Name:    "list",
                                Aliases: []string{"ls"},
                                Usage:   "list",
                                Action:  groups.List,
                        },
                },
        }
}</span>

func createProfileCommands() *cli.Command <span class="cov0" title="0">{
        return &amp;cli.Command{
                Name:     "profiles",
                Aliases:  []string{"p"},
                Action:   profile.Switch,
                HideHelp: true,
                Subcommands: []*cli.Command{
                        {
                                Name:    "list",
                                Aliases: []string{"ls"},
                                Usage:   "list",
                                Action:  profile.List,
                        },
                        {
                                Name:    "create",
                                Aliases: []string{"c"},
                                Usage:   "create &lt;name&gt;",
                                Action:  profile.Create,
                        },
                        {
                                Name:     "switch",
                                Aliases:  []string{"s"},
                                Usage:    "switch",
                                Action:   profile.Switch,
                                HideHelp: true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "github.com/rollicks-c/configcove"
        "github.com/rollicks-c/configcove/profiles"
        "github.com/rollicks-c/secretblendproviders/envvar"
)

type PortGroup struct {
        Target       Target        `yaml:"target"`
        PortForwards []PortForward `yaml:"portForwards"`
        Name         string        `yaml:"name"`
}

type Target struct {
        K8sConfigFile string `yaml:"k8sConfigFile"`
        K8sContext    string `yaml:"k8sContext"`
}

type PortForward struct {
        Namespace  string `yaml:"namespace"`
        Service    string `yaml:"service"`
        LocalPort  string `yaml:"localPort"`
        RemotePort string `yaml:"remotePort"`
}

type Config struct {
        Groups []PortGroup `yaml:"groups"`
}

func init() <span class="cov8" title="1">{
        _ = envvar.RegisterGlobally()
}</span>

func Profiles() *profiles.Manager[Config] <span class="cov0" title="0">{
        pm := configcove.Profiles[Config](AppName)
        return pm
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package forwarding

import (
        "fmt"
        "github.com/rollicks-c/kgate/internal/config"
        "github.com/rollicks-c/kgate/internal/logic/model"
        "time"
)

func CreateForwarder(group config.PortGroup, def config.PortForward) model.Process <span class="cov0" title="0">{

        return &amp;managedForwarder{
                group:       group,
                serviceName: def.Service,
                namespace:   def.Namespace,
                localPort:   def.LocalPort,
                remotePort:  def.RemotePort,
                readyCh:     make(chan struct{}),
                timeout:     time.Second * 5,
        }

}</span>

func (m managedForwarder) ID() string <span class="cov0" title="0">{
        return m.hash()
}</span>

func (m managedForwarder) Group() string <span class="cov0" title="0">{
        return m.group.Name
}</span>

func (m managedForwarder) Describe() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s/%s:%s", m.localPort, m.namespace, m.serviceName, m.remotePort)
}</span>

func (m managedForwarder) Run(c model.Controller) <span class="cov0" title="0">{

        // setup port-forwarder
        pf, err := m.createPortForwarder(c.StopChannel())
        if err != nil </span><span class="cov0" title="0">{
                c.UpdateProcess(m, model.Failure, err.Error())
                return
        }</span>

        <span class="cov0" title="0">m.run(c, pf)</span>

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package forwarding

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "github.com/rollicks-c/kgate/internal/config"
        "github.com/rollicks-c/kgate/internal/logic/model"
        "io"
        "k8s.io/client-go/tools/portforward"
        "k8s.io/client-go/transport/spdy"
        "net/http"
        "time"
)

type managedForwarder struct {
        group                  config.PortGroup
        serviceName, namespace string
        localPort, remotePort  string
        readyCh                chan struct{}
        timeout                time.Duration
}

type portForwarder interface {
        ForwardPorts() error
}

func (m managedForwarder) run(c model.Controller, pf portForwarder) <span class="cov0" title="0">{

        hasError := false

        // start session
        go func() </span><span class="cov0" title="0">{

                // setup cleanup
                defer c.StopWaitGroup().Done()
                c.StopWaitGroup().Add(1)

                // start port-forwarding
                err := pf.ForwardPorts()

                // handle errors
                if err != nil </span><span class="cov0" title="0">{
                        c.UpdateProcess(
                                m,
                                model.Failure,
                                err.Error(),
                        )
                        hasError = true
                }</span> else<span class="cov0" title="0"> {
                        c.UpdateProcess(
                                m,
                                model.Stopped,
                                "",
                        )
                }</span>
        }()

        // await readiness or timeout
        <span class="cov0" title="0">select </span>{
        case &lt;-m.readyCh:<span class="cov0" title="0">
                c.UpdateProcess(
                        m,
                        model.Running,
                        "",
                )</span>
        case &lt;-time.After(m.timeout):<span class="cov0" title="0">
                if !hasError </span><span class="cov0" title="0">{
                        c.UpdateProcess(
                                m,
                                model.Failure,
                                fmt.Sprintf("timeout occured (%s)", m.timeout.String()),
                        )
                }</span>
        }

}

func (m managedForwarder) hash() string <span class="cov8" title="1">{
        hash := sha256.New()
        hash.Write([]byte(fmt.Sprintf("%v:%s:%s:%s:%s", m.group, m.serviceName, m.namespace, m.localPort, m.remotePort)))
        return hex.EncodeToString(hash.Sum(nil))
}</span>

func (m managedForwarder) createPortForwarder(stopChan chan struct{}) (*portforward.PortForwarder, error) <span class="cov0" title="0">{

        // gather pod
        client, conf, err := createClient(m.group.Target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">podName, err := getPodForService(client, m.serviceName, m.namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get pod for service %s: %v", m.serviceName, err)
        }</span>

        // prep port-forwarding request
        <span class="cov0" title="0">url := client.CoreV1().RESTClient().Post().
                Resource("pods").
                Namespace(m.namespace).
                Name(podName).
                SubResource("portforward").
                URL()
        transport, upgrader, err := spdy.RoundTripperFor(conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create round-tripper: %v", err)
        }</span>

        // create port forward
        <span class="cov0" title="0">dialer := spdy.NewDialer(upgrader, &amp;http.Client{Transport: transport}, http.MethodPost, url)
        ports := []string{fmt.Sprintf("%s:%s", m.localPort, m.remotePort)}
        pf, err := portforward.New(dialer, ports, stopChan, m.readyCh, io.Discard, io.Discard)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create port-forward: %v", err)
        }</span>

        // port-forwarding ready
        <span class="cov0" title="0">return pf, nil</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">package forwarding

import (
        "context"
        "fmt"
        "github.com/rollicks-c/kgate/internal/config"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "strings"
)

func createClient(target config.Target) (*kubernetes.Clientset, *rest.Config, error) <span class="cov0" title="0">{

        // load kube config
        loadingRules := &amp;clientcmd.ClientConfigLoadingRules{ExplicitPath: target.K8sConfigFile}
        configOverrides := &amp;clientcmd.ConfigOverrides{
                CurrentContext: target.K8sContext,
        }
        kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
        clientConfig, err := kubeConfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // create client
        <span class="cov0" title="0">clientSet, err := kubernetes.NewForConfig(clientConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create Kubernetes client: %v", err)
        }</span>

        <span class="cov0" title="0">return clientSet, clientConfig, nil</span>
}

func getPodForService(clientSet *kubernetes.Clientset, serviceName, namespace string) (string, error) <span class="cov0" title="0">{

        // gather all pods in NS
        pods, err := clientSet.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to list pods: %v", err)
        }</span>

        // find pod for service
        <span class="cov0" title="0">for _, pod := range pods.Items </span><span class="cov0" title="0">{
                if strings.Contains(pod.Name, serviceName) </span><span class="cov0" title="0">{
                        return pod.Name, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no pod found for service %s", serviceName)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package gate

import (
        "fmt"
        "github.com/rollicks-c/kgate/internal/config"
)

func RunGroups(groups ...config.PortGroup) error <span class="cov0" title="0">{

        // sanity check
        if len(groups) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no groups found")
        }</span>

        // start session
        <span class="cov0" title="0">newController(groups...).Run()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package gate

import (
        "context"
        "github.com/rollicks-c/kgate/internal/config"
        "github.com/rollicks-c/kgate/internal/logic/forwarding"
        "github.com/rollicks-c/kgate/internal/logic/model"
        "github.com/rollicks-c/kgate/internal/logic/ui"
        "github.com/rollicks-c/term"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"
)

const (
        defaultMessage = "press [yellow::b]q[-::-] to quit | [yellow::b]s[-::-] to stop/resume"
)

type controller struct {

        // data
        groups  []config.PortGroup
        session *session

        // rendering
        view       model.Frontend
        statusChan chan model.Update

        // runtime
        ctx     model.Context
        ctxStop context.CancelFunc
}

func (c controller) StopChannel() chan struct{} <span class="cov0" title="0">{
        return c.session.stopChan
}</span>

func (c controller) StopWaitGroup() *sync.WaitGroup <span class="cov0" title="0">{
        return c.session.wg
}</span>

func newController(groups ...config.PortGroup) *controller <span class="cov0" title="0">{

        // create context
        runContext, ctxStop := context.WithCancel(context.Background())
        ctx := model.Context{
                Context: runContext,
                WG:      &amp;sync.WaitGroup{},
        }

        // create controller
        c := &amp;controller{
                groups:     groups,
                ctx:        ctx,
                ctxStop:    ctxStop,
                statusChan: make(chan model.Update),
        }
        c.session = newSession()
        c.view = ui.NewFancy()

        return c
}</span>

func (c controller) Run() <span class="cov0" title="0">{

        // start frontend
        go c.view.Run(c)
        go c.runUpdateLoop()

        // start forwards
        c.view.ShowMessage("[orange]starting port forwards...")
        c.startSession()

        // listen to terminate signals
        c.view.ShowMessage(defaultMessage)
        sigChan := make(chan os.Signal)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        select </span>{
        case &lt;-sigChan:<span class="cov0" title="0"></span>
        case &lt;-c.ctx.Done():<span class="cov0" title="0"></span>
        }

        // controlled shutdown
        <span class="cov0" title="0">c.shutdown()</span>
}

func (c controller) TogglePause() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                if c.session.isStopped </span><span class="cov0" title="0">{
                        c.session.reset()
                        c.startSession()
                }</span> else<span class="cov0" title="0"> {
                        c.stopSession()
                }</span>
        }()
}

func (c controller) Quit() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                c.view.ShowMessage("[orange]stopping port forwards...")
                c.stopSession()
                &lt;-time.After(500 * time.Millisecond)
                c.ctxStop()
                _ = syscall.Kill(os.Getpid(), syscall.SIGTERM)
        }</span>()
}

func (c controller) UpdateProcess(proc model.Process, state model.Status, msg string) <span class="cov0" title="0">{
        update := model.Update{
                ID:          proc.ID(),
                SortIndex:   c.session.oridnalView[proc.ID()],
                Group:       proc.Group(),
                PortForward: proc.Describe(),
                Status:      state,
                Message:     msg,
        }
        c.statusChan &lt;- update
}</span>

func (c controller) runUpdateLoop() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case event := &lt;-c.statusChan:<span class="cov0" title="0">
                        c.view.Update(event)</span>
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (c controller) shutdown() <span class="cov0" title="0">{

        term.Warnf("shutting down app...\n")

        // stop UI
        close(c.statusChan)
        c.view.Stop()

        // stop all routines
        c.ctxStop()
        c.ctx.WG.Wait()
}</span>

func (c controller) startSession() <span class="cov0" title="0">{

        // iterate all port forwards
        for _, g := range c.groups </span><span class="cov0" title="0">{
                for _, pf := range g.PortForwards </span><span class="cov0" title="0">{

                        // create and run processes
                        proc := forwarding.CreateForwarder(g, pf)
                        c.session.addProcess(proc)
                        go proc.Run(c)
                }</span>
        }
}

func (c controller) stopSession() <span class="cov0" title="0">{

        // session already aborted
        if c.session.isStopped </span><span class="cov0" title="0">{
                return
        }</span>

        // stop all forwards
        <span class="cov0" title="0">close(c.session.stopChan)
        c.session.wg.Wait()

        // mark session as aborted
        c.session.isStopped = true</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package gate

import (
        "github.com/rollicks-c/kgate/internal/logic/model"
        "sort"
        "sync"
)

type session struct {

        // data
        processes   map[string]model.Process
        oridnalView map[string]int
        isStopped   bool

        // runtime
        stopChan chan struct{}
        wg       *sync.WaitGroup
}

func newSession() *session <span class="cov0" title="0">{
        s := &amp;session{}
        s.reset()
        return s
}</span>

func (s *session) reset() <span class="cov0" title="0">{
        s.isStopped = false
        s.stopChan = make(chan struct{})
        s.processes = make(map[string]model.Process)
        s.oridnalView = make(map[string]int)
        s.wg = &amp;sync.WaitGroup{}
}</span>

func (s *session) addProcess(proc model.Process) <span class="cov0" title="0">{
        s.processes[proc.ID()] = proc
        s.buildOrdinalView()
}</span>

func (s *session) buildOrdinalView() <span class="cov0" title="0">{
        list := make([]model.Process, 0, len(s.processes))
        for _, p := range s.processes </span><span class="cov0" title="0">{
                list = append(list, p)
        }</span>
        <span class="cov0" title="0">sort.Slice(list, func(i, j int) bool </span><span class="cov0" title="0">{
                if list[i].Group() == list[j].Group() </span><span class="cov0" title="0">{
                        return list[i].Describe() &lt; list[j].Describe()
                }</span>
                <span class="cov0" title="0">return list[i].Group() &lt; list[j].Group()</span>
        })
        <span class="cov0" title="0">for i, p := range list </span><span class="cov0" title="0">{
                s.oridnalView[p.ID()] = i
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ui

import (
        "github.com/rollicks-c/kgate/internal/logic/model"
        "github.com/rollicks-c/kgate/internal/logic/ui/fancy"
        "github.com/rollicks-c/kgate/internal/logic/ui/simple"
)

func NewSimple() model.Frontend <span class="cov0" title="0">{
        return simple.New()
}</span>

func NewFancy() model.Frontend <span class="cov0" title="0">{
        return fancy.New()
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package fancy

import (
        "github.com/rivo/tview"
        "github.com/rollicks-c/kgate/internal/logic/model"
        "github.com/rollicks-c/term"
)

type Frontend struct {
        app     *tview.Application
        layout  *appLayout
        records map[string]int // id-&gt;row
}

func New() *Frontend <span class="cov0" title="0">{

        // build app
        layout := createLayout()
        app := tview.NewApplication().
                EnableMouse(false).
                SetRoot(layout.root, true)

        return &amp;Frontend{
                app:     app,
                layout:  layout,
                records: map[string]int{},
        }
}</span>

func (f Frontend) Run(controller model.Controller) <span class="cov0" title="0">{

        // install event handlers
        f.setupKeyHandler(controller)

        // run
        if err := f.app.Run(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

}

func (f Frontend) ShowMessage(msg string) <span class="cov0" title="0">{
        f.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                f.layout.msgBox.SetText(msg + " ")
        }</span>)
}

func (f Frontend) Stop() <span class="cov0" title="0">{
        f.app.Stop()
        term.Warnf("shutting down UI\n")
        f.app.SetScreen(nil)
}</span>

func (f Frontend) Update(update model.Update) <span class="cov0" title="0">{
        f.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                f.updateTableRow(update)
        }</span>)
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package fancy

import (
        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
        "github.com/rollicks-c/kgate/internal/logic/model"
        "os"
        "syscall"
)

func (f Frontend) setupKeyHandler(controller model.Controller) <span class="cov0" title="0">{

        f.app.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if event.Rune() == 's' </span><span class="cov0" title="0">{
                        controller.TogglePause()
                }</span>
                <span class="cov0" title="0">if event.Rune() == 'q' </span><span class="cov0" title="0">{
                        controller.Quit()
                }</span>
                <span class="cov0" title="0">if event.Key() == tcell.KeyCtrlC </span><span class="cov0" title="0">{
                        controller.Quit()
                        _ = syscall.Kill(os.Getpid(), syscall.SIGTERM)
                }</span>
                <span class="cov0" title="0">return event</span>
        })

}

func (f Frontend) getStatusColor(value model.Status) tcell.Color <span class="cov0" title="0">{
        switch value </span>{
        case model.Running:<span class="cov0" title="0">
                return tcell.ColorGreen</span>
        case model.Stopped:<span class="cov0" title="0">
                return tcell.ColorOrange</span>
        case model.Restart:<span class="cov0" title="0">
                return tcell.ColorYellow</span>
        case model.Failure:<span class="cov0" title="0">
                return tcell.ColorRed</span>
        default:<span class="cov0" title="0">
                return tcell.ColorWhite</span>
        }
}

func (f Frontend) getStatusText(value model.Status) string <span class="cov0" title="0">{

        switch value </span>{
        case model.Running:<span class="cov0" title="0">
                return "🟢 Running"</span>
        case model.Stopped:<span class="cov0" title="0">
                return "⛔ Stopped"</span>
        case model.Restart:<span class="cov0" title="0">
                return "🔄 Restarting"</span>
        case model.Failure:<span class="cov0" title="0">
                return "❌ Failure"</span>
        default:<span class="cov0" title="0">
                return "⚪ Unknown"</span>
        }
}

func (f Frontend) updateTableRow(update model.Update) <span class="cov0" title="0">{

        row := update.SortIndex + 1

        f.layout.table.SetCell(row, 0,
                tview.NewTableCell(padText(update.Group, 10)).
                        SetTextColor(tcell.ColorWhite).
                        SetAlign(tview.AlignLeft).
                        SetSelectable(true),
        )
        f.layout.table.SetCell(row, 1,
                tview.NewTableCell(padText(update.PortForward, 45)).
                        SetTextColor(tcell.ColorLightBlue).
                        SetAlign(tview.AlignLeft).
                        SetSelectable(true),
        )
        f.layout.table.SetCell(row, 2,
                tview.NewTableCell(padText(f.getStatusText(update.Status), 20)).
                        SetTextColor(f.getStatusColor(update.Status)).
                        SetAlign(tview.AlignLeft).
                        SetSelectable(true),
        )
        f.layout.table.SetCell(row, 3,
                tview.NewTableCell(update.Message).
                        SetTextColor(f.getStatusColor(update.Status)).
                        SetTextColor(f.getStatusColor(update.Status)).
                        SetAlign(tview.AlignLeft).
                        SetSelectable(false),
        )
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package fancy

import (
        "fmt"
        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
        "github.com/rollicks-c/kgate/internal/config"
)

type appLayout struct {
        root   *tview.Flex
        msgBox *tview.TextView
        table  *tview.Table
}

func createLayout() *appLayout <span class="cov0" title="0">{

        // create controls
        header, msgBox := createHeader()
        table := createTable()

        // setup appLayout
        flex := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(header, 3, 1, false).
                AddItem(table, 0, 1, true)

        return &amp;appLayout{
                root:   flex,
                msgBox: msgBox,
                table:  table,
        }

}</span>

func createHeader() (*tview.Flex, *tview.TextView) <span class="cov0" title="0">{

        // create controls
        titleView := tview.NewTextView().
                SetText(fmt.Sprintf("[yellow::b] %s", config.AppName)).
                SetDynamicColors(true).
                SetTextAlign(tview.AlignLeft)

        msgView := tview.NewTextView().
                SetText("").
                SetDynamicColors(true).
                SetTextAlign(tview.AlignRight)

        // appLayout
        headerFlex := tview.NewFlex().
                SetDirection(tview.FlexColumn).
                AddItem(titleView, 0, 1, false).
                AddItem(nil, 0, 2, false).
                AddItem(msgView, 50, 0, false)
        headerFlex.SetBorder(true)

        return headerFlex, msgView

}</span>

func createTable() *tview.Table <span class="cov0" title="0">{

        // create table
        table := tview.NewTable().
                SetBorders(false).
                SetSelectable(false, false)

        // add headers
        headers := []string{"Group", "Port Forward", "Status", "Info"}
        widths := []int{15, 15, 10, 25} // Column width for padding
        for i, header := range headers </span><span class="cov0" title="0">{
                table.SetCell(0, i,
                        tview.NewTableCell(padText(header, widths[i])).
                                SetTextColor(tcell.ColorBlack).
                                SetBackgroundColor(tcell.ColorWhite).
                                SetAlign(tview.AlignLeft).
                                SetSelectable(false).
                                SetStyle(tcell.StyleDefault.Bold(true)),
                )
        }</span>

        <span class="cov0" title="0">return table</span>
}

func padText(text string, width int) string <span class="cov0" title="0">{
        if len(text) &gt;= width </span><span class="cov0" title="0">{
                return text[:width]
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%-*s", width, text)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package simple

import (
        "fmt"
        "github.com/rollicks-c/kgate/internal/logic/model"
        "os"
        "os/exec"
        "runtime"
)

type Frontend struct {
        procList map[string]model.Update
}

func (f Frontend) Run(controller model.Controller) {<span class="cov0" title="0">
}</span>

func New() *Frontend <span class="cov0" title="0">{
        return &amp;Frontend{
                procList: make(map[string]model.Update),
        }
}</span>

func (f Frontend) ShowMessage(msg string) <span class="cov0" title="0">{
        fmt.Println(msg)
}</span>

func (f Frontend) Stop() <span class="cov0" title="0">{
        f.clearTerminal()
}</span>

func (f Frontend) Update(update model.Update) <span class="cov0" title="0">{
        f.clearTerminal()
        f.procList[update.ID] = update
        for _, proc := range f.procList </span><span class="cov0" title="0">{
                fmt.Println(proc)
        }</span>

}

func (f Frontend) clearTerminal() <span class="cov0" title="0">{
        var cmd *exec.Cmd
        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                cmd = exec.Command("cmd", "/c", "cls")</span>
        default:<span class="cov0" title="0">
                cmd = exec.Command("clear")</span>
        }
        <span class="cov0" title="0">cmd.Stdout = os.Stdout
        cmd.Run()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
